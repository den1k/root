{"version":3,"sources":["expound/problems.cljc"],"mappings":"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","names":["expound.problems/adjust-in","form","problem","in1","expound.paths/in-with-kps","in2","paths","expound.paths/paths-to-value","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","cljs.core/count","cljs.core/first","in3","e102073","cljs.spec.alpha/unform","cljs.core/last","_e","new-in","or__4185__auto__","G__102077","fexpr__102076","cljs.core.assoc.cljs$core$IFn$_invoke$arity$3","expound.problems/adjust-path","failure","cljs.core/vec","cljs.core/rest","expound.problems/add-spec","spec","expound.problems/fix-via","cljs.core.into.cljs$core$IFn$_invoke$arity$2","expound.problems/missing-spec?","_failure","expound.problems/not-in-set?","cljs.core/set?","expound.problems/fspec-exception-failure?","cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2","expound.problems/fspec-ret-failure?","expound.problems/fspec-fn-failure?","expound.problems/check-ret-failure?","expound.problems/check-fn-failure?","expound.problems/missing-key?","pred","cljs.core/seq?","cljs.spec.alpha.valid_QMARK_.cljs$core$IFn$_invoke$arity$2","cljs.core.nth.cljs$core$IFn$_invoke$arity$2","expound.problems/insufficient-input?","cljs.core/contains?","expound.problems/extra-input?","expound.problems/ptype","skip-locations?","cljs.core/not","expound.problems/annotate","explain-data","map__102088","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core/hash-map","cljs.core.get.cljs$core$IFn$_invoke$arity$2","problems","value","args","ret","fn","caller","cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2","problems'","cljs.core.map.cljs$core$IFn$_invoke$arity$2","p1__102086#","p1__102087#","cljs.core.comp.cljs$core$IFn$_invoke$arity$variadic","cljs.core.partial.cljs$core$IFn$_invoke$arity$2","cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic","expound.problems/type","expound.problems/value-in","expound.paths/value-in"],"sourcesContent":["(ns ^:no-doc expound.problems\n  (:require [expound.paths :as paths]\n            [clojure.spec.alpha :as s])\n  (:refer-clojure :exclude [type]))\n\n;; can simplify when \n;; https://dev.clojure.org/jira/browse/CLJ-2192 or\n;; https://dev.clojure.org/jira/browse/CLJ-2258 are fixed\n(defn- adjust-in [form problem]\n  ;; Three strategies for finding the value...\n  (let [;; 1. Find the original value\n        in1 (paths/in-with-kps form (:val problem) (:in problem) [])\n\n        ;; 2. If value is unique, just find that, ignoring the 'in' path\n        in2 (let [paths (paths/paths-to-value form (:val problem) [] [])]\n              (if (= 1 (count paths))\n                (first paths)\n                nil))\n\n        ;; 3. Find the unformed value (if there is an unformer)\n        in3 (try\n              (paths/in-with-kps form\n                                 (s/unform (last (:via problem)) (:val problem))\n                                 (:in problem) [])\n              ;; The unform fails if there is no unformer\n              ;; and the unform function could throw any type of\n              ;; exception (it's provided by user)\n              (catch #?(:cljs :default\n                        :clj java.lang.Throwable) _e\n                nil))\n        new-in (cond in1\n                     in1\n\n                     in2\n                     in2\n\n                     in3\n                     in3\n\n                     (or (= '(apply fn) (:pred problem))\n                         (#{:ret} (first (:path problem))))\n                     (:in problem)\n\n                     :else\n                     nil)]\n\n    (assoc problem\n           :expound/in\n           new-in)))\n\n(defn- adjust-path [failure problem]\n  (assoc problem :expound/path\n         (if (= :instrument failure)\n           (vec (rest (:path problem)))\n           (:path problem))))\n\n(defn- add-spec [spec problem]\n  (assoc problem :spec spec))\n\n;; via is slightly different when using s/assert\n(defn fix-via [spec problem]\n  (if (= spec (first (:via problem)))\n    (assoc problem :expound/via (:via problem))\n    (assoc problem :expound/via (into [spec] (:via problem)))))\n\n(defn ^:private missing-spec? [_failure problem]\n  (= \"no method\" (:reason problem)))\n\n(defn ^:private not-in-set? [_failure problem]\n  (set? (:pred problem)))\n\n(defn ^:private fspec-exception-failure? [failure problem]\n  (and (not= :instrument failure)\n       (not= :check-failed failure)\n       (= '(apply fn) (:pred problem))))\n\n(defn ^:private fspec-ret-failure? [failure problem]\n  (and\n   (not= :instrument failure)\n   (not= :check-failed failure)\n   (= :ret (last (:path problem)))))\n\n(defn ^:private fspec-fn-failure? [failure problem]\n  (and\n   (not= :instrument failure)\n   (not= :check-failed failure)\n   (= :fn (last (:path problem)))))\n\n(defn ^:private check-ret-failure? [failure problem]\n  (and\n   (= :check-failed failure)\n   (= :ret (last (:path problem)))))\n\n(defn ^:private check-fn-failure? [failure problem]\n  (and (= :check-failed failure)\n       (= :fn (last (:path problem)))))\n\n(defn ^:private missing-key? [_failure problem]\n  (let [pred (:pred problem)]\n    (and (seq? pred)\n         (< 2 (count pred))\n         (s/valid?\n          :expound.spec/contains-key-pred\n          (nth pred 2)))))\n\n(defn ^:private insufficient-input? [_failure problem]\n  (contains? #{\"Insufficient input\"} (:reason problem)))\n\n(defn ^:private extra-input? [_failure problem]\n  (contains? #{\"Extra input\"} (:reason problem)))\n\n(defn ^:private ptype [failure problem skip-locations?]\n  (cond\n    (:expound.spec.problem/type problem)\n    (:expound.spec.problem/type problem)\n\n    ;; This is really a location of a failure, not a failure type\n    (and (not skip-locations?) (fspec-ret-failure? failure problem))\n    :expound.problem/fspec-ret-failure\n\n    (fspec-exception-failure? failure problem)\n    :expound.problem/fspec-exception-failure\n\n    ;; This is really a location of a failure, not a failure type\n    ;; (compare to check-fn-failure, which is also an fn failure, but\n    ;; at a different location)\n    (and (not skip-locations?) (fspec-fn-failure? failure problem))\n    :expound.problem/fspec-fn-failure\n\n    ;; This is really a location of a failure, not a failure type\n    (and (not skip-locations?) (check-ret-failure? failure problem))\n    :expound.problem/check-ret-failure\n\n    ;; This is really a location of a failure, not a failure type\n    (and (not skip-locations?) (check-fn-failure? failure problem))\n    :expound.problem/check-fn-failure\n\n    (insufficient-input? failure problem)\n    :expound.problem/insufficient-input\n\n    (extra-input? failure problem)\n    :expound.problem/extra-input\n\n    (not-in-set? failure problem)\n    :expound.problem/not-in-set\n\n    (missing-key? failure problem)\n    :expound.problem/missing-key\n\n    (missing-spec? failure problem)\n    :expound.problem/missing-spec\n\n    :else\n    :expound.problem/unknown))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;; public ;;;;;;;;;;;;;;;;;;;;;;;;;\n\n\n(defn annotate [explain-data]\n  (let [{::s/keys [problems value args ret fn failure spec]} explain-data\n        caller (or (:clojure.spec.test.alpha/caller explain-data) (:orchestra.spec.test/caller explain-data))\n        form (if (not= :instrument failure)\n               value\n               (cond\n                 (contains? explain-data ::s/ret) ret\n                 (contains? explain-data ::s/args) args\n                 (contains? explain-data ::s/fn) fn\n                 :else (throw (ex-info \"Invalid explain-data\" {:explain-data explain-data}))))\n        problems' (map (comp (partial adjust-in form)\n                             (partial adjust-path failure)\n                             (partial add-spec spec)\n                             (partial fix-via spec)\n                             #(assoc % :expound/form form)\n                             #(assoc % :expound.spec.problem/type (ptype failure % false)))\n                       problems)]\n\n    (-> explain-data\n        (assoc :expound/form form\n               :expound/caller caller\n               :expound/problems problems'))))\n\n(def type ptype)\n\n;; Must keep this function here because\n;; spell-spec uses it\n;; https://github.com/bhauman/spell-spec/blob/48ea2ca544f02b04a73dc42a91aa4876dcc5fc95/src/spell_spec/expound.cljc#L20\n(def value-in paths/value-in)\n"]}